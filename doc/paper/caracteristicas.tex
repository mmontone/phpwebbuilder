\section{Características del Modelo}

\subsection{Persistencia}
\label{sub-pers}
La persistencia del modelo se hace mediante la subclasificación de una clase especial (PersistentObject).
Esta clase provee los métodos necesarios para describir la metadata en su inicialización, y también para las
operaciones de guardado y borrado.
Luego, para la recuperacion de objetos, existe la clase Report, que permite obtener los objetos de una
coleccion, filtrada por varios criterios y ordenada. Estos reportes tienen en cuenta las subclases de los
objetos, y utilizan herencia para las variables de instancia.

\subsection{OQL}
\label{sub-oql}
Dada la complejidad de construir un reporte completo a mano, desarrollamos un lenguaje OQL para consulta de
los objetos, que construye un reporte.

El lenguaje está íntimamente relacionado con el código PHP, ya que puede utilizar las variables en el scope.
Además, puede hacer consultas utilizando la identidad de los objetos.
\subsection{Adaptación de base de datos}
\label{sub-adapt}
En el desarrollo del modelo, incluímos todo lo que es persistencia. Establecemos el los tipos de las variables
de cada clase, y las relaciones de subclasificación.

De este modelo, la información del esquema de persistencia para una base de datos relacional se puede deducir.
Por esto, también podemos generar el esquema automáticamente, liberando de esta carga al programador.

Además, podemos verificar que el esquema de base de datos sea el correcto, y mostrar y ejecutar las correcciones
necesarias. Esto también es muy útil cuando se hace una modificacion en el modelo de una aplicación, y se necesita
adaptar la base de datos a los nuevos cambios.
\section{Características del Controller}

\subsection{Componentes}
\label{sub-comp}

Las aplicaciones se construyen mediante ensamblado de componentes. Estos componentes son reutilizables,
ya que pueden ser parametrizados, pueden levantar eventos, y pueden contener otros componentes.

Un componente puede llamar a otro para realizar una tarea (por ejemplo, un componente Welcome, ante un click
del usuario en un botón "Ingresar", puede llamar al componente Login), y esperar la respuesta de este
componente para continuar su ejecución (cuando el componente devuelve el usuario validado).
\subsection{Widgets}
\label{sub-widget}

Existen unos componentes especiales, llamados Widgets, que permiten interactuar con el usuario (por ejemplo
con el componente Input, que permite recibir un string del usuario, el Text, que le presenta un texto, o el
CheckBox, que presenta un checkbox).

\subsection{Multiple Dispatching y Context Dispatching}
\label{sub-dispatch}
Otra característica llamativa, es el múltiple dispatching de funciones.
Dado que muchas veces el método a utilizar depende de más de una clase, las funciones de múltiple dispatching nos ayudan a resolver este problema.

Primero se define la función, con los parametros a utilizar tipados, y luego se hace el llamado, que utiliza los tipos de los parámetros para
resolver el método a utilizar

Además, las funciones de múltiple dispatching pueden ser utilizadas pasando el contexto (la rama de componentes dentro de la que se hace el llamado)
de aplicación, para de esta manera poder responder de manera diferente a un evento, dependiendo del contexto.

Por ejemplo, podemos tener un componente TaskList que muestre las tareas realizada en un día. Para cada tarea muestra la descripción, la hora, y el
nombre de quién la completo en un componente TaskList. Si luego quisieramos ver las tareas realizadas por uno de los usuarios, nos interesaría ver
la hora, la descripción, pero no el nombre del usuario, porque ya se sabe por el contexto. Podríamos usar en ese caso un componente UserTaskShow.

Para implementar esa diferencia, una forma común sería tener 2 componentes, TaskList y UserTaskList. Esto duplica código, y además es difícil de
implementar cuando el contexto de los componentes es de varios componentes (ya que tendríamos que hacer un nuevo componente para cada elemento en
la rama de componentes hasta llegar al que realmente implementa la diferencia).

Entonces, podemos utilizar el Context Dispatching para elegir un componente UserTaskShow, en lugar del otro, el TaskShow, independientemente del nivel de
anidamiento del componente que hace el dispatch y el componente que provee el contexto.


\section{Características de la Vista}

\subsection{Templates}
\label{sub-templates}
Para la generación de interfaz, utilizamos la técnica conocida de los templates.
Por comodidad, agregamos las siguientes características:

- Los templates se "heredan", así que un Componente subclase de otro que tiene template, hereda de este el
template (siempre y cuando no tenga uno más específico). También son heredables por Mixins.

- Los templates son declarativos: No incluyen comandos ni iteradores (como tienen engines como el Smarty).
De esta manera, el control de la aplicación está 100\% en los componentes, y además nos aseguramos que los
templates generen un XML bien formado.

- Los templates están basados en XML, con un par de tags extras (<template> y <container>), así que se puede
generar cualquier XML (como XHTML) para mostrar los componentes.

Además, cada componente tiene un template default, por lo que no se necesita crearle uno para tener la aplicación
funcionando.

\subsubsection{Adaptación de Diseños existentes}
\label{sub-templates-adapt}
Debido a que los templates son XML, se puede tomar una página en HTML y agregarle los tags <template> y <container> donde
se quiera, y de esta manera conseguir un template a muy bajo costo.
Además, como los templates se heredan, utilizando clases bien acomodadas, una aplicación queda con un diseño completo en
solo 3 o 4 templates.


\subsection{Renderings}
\label{sub-render}
El rendereo de la aplicación se hace 100\% mediante PWB, y además todo lo generado es XML bien formado, de
modo que de manera transparente podemos renderear en AJAX.

La manera de cambiar el engine de rendereo es tan simple como cambiar en el archivo de configuración, donde
dice page\_renderer=StandardPageRenderer por page\_renderer=AjaxPageRenderer, o incluso por page\_renderer=CometPageRenderer
o page\_renderer=XULPageRenderer

\subsubsection{Comet}

Comet es una tecnología similar a AJAX, que se caracteriza por mantener una conexión abierta con el servidor
en todo momento. PWB aprovecha esto, ya que un importante tiempo de procesamiento de los scripts PHP es la
carga del script y los datos de la sesión de usuario, que en este caso quedan vivos en la memoria del servidor.

Mediante pasaje de mensajes de otro script, que envía los datos a la aplicación PWB ejecutándose, podemos
mantener la sesión en memoria, mejorando los tiempos de respuesta, e incluso modificando la aplicación del
usuario no solamente cuando éste genera un evento (un click del mouse), sino también cuando, por ejemplo, la base
de datos es modificada.

\subsubsection{XUL}

El proyecto Mozilla incluye un subproyecto llamado XUL. XUL es un lenguaje de definición de interfaces desktop
en XML. Dado que la salida de la aplicación debe ser un XML bien formado, y que la interacción usuario-interfaz
se hace mediante javascript, PWB soporta un XUL Page Renderer, que renderea aplicaciones en XUL. La
diferencia para el usuario, es en los tags de los templates, ya que debe utilizar elementos XUL en lugar de
HTML. Dado que los templates de HTML llevan extensión .xml, y los de xul .xul, la misma aplicación, con tener
templates de los 2 tipos para cada componente, puede ser rendereada de las 2 maneras.

\section{Características del PITS}

\subsection{BugNotifier}

PWB incluye un BugNotifier, que automatiza el manejo de errores "no manejados", permitiendo al usuario que
encuentra una condición de error dentro de la aplicación, enviar el reporte de error a un mail configurado a
tal fin, y también reiniciar la aplicación para continuar utilizándola.
%PITS

\subsection{Eventos}
\label{sub-events}
PWB implementa un mecanismo simple de eventos. Todo objeto PWBObject implementa los mensajes addInterestIn, que permite a otro objeto escuchar un evento,
y triggerEvent, que acciona un evento.

Los widgets además accionan eventos en cada acción del usuario, y los objetos del modelo cuando son modificados.


\subsection{Weak References}
\label{sub-weak}
Cuando un objeto \$x queda escuchando un evento de un PWBObject \$y, este último necesita guardar una referencia al primero. En caso de que, por el flujo de la
aplicación, \$x deje de ser necesario, el mecanismo de garbage collection de PHP no puede descartarlo, porque \$y lo conserva referenciado, aunque no lo
necesite realmente.

Por esto implementamos un mecanismo de Weak References, en donde \$y se queda con una referencia de \$x, pero de la cual el garbage collector no se entera,
permitiendo borrar a \$x en caso de que sea necesario.


\subsection{PHPCC}
\label{sub-phpcc}
Para crear el lenguaje OQL, debimos crear un Compiler Compiler para PHP (otros conocidos son Bison, yacc).
De esta manera ahora también se puede extender el framework con múltiples DSLs.

\subsection{Macros}
\label{sub-macros}
Otra funcionalidad interesante, es la utilización de macros. Como se ve en lenguajes como C, las macros pueden \
llegar a tener un rol muy importante en un proyecto, ya que son otra forma de modularización.

Dentro de PWB mismo, tenemos varios tipos de macros:

Las macros, lam, y select, que permiten hacer un pre-procesamiento del código, generando código PHP con
mayor funcionalidad:
\verb"#@ select u:User where u.name='pepito'@#"
genera un objeto reporte completo, con todos los usuarios llamados pepito, en código PHP.

Y por otro lado, las macros para validación de código, que hacen tests, útiles para el momento del desarrollo
pero consumidoras de tiempo valioso en tiempo de deployment.

Estas son typecheck, y check:
\verb"#@typecheck $c: Component, $u: User@#"
que chequea que las variables \verb"$c" y \verb"$u" sean un Component y un User, respectivamente. En las opciones de
configuración de la aplicación, habilitamos o dehabilitamos el typechecking, y el chequeo no se incluye.

\subsection{Mixins}
\label{sub-mixins}
Otra funcionalidad interesante, es la de los mixins. Muchos lenguages la ya incluyen, y nosotros se la
implementamos (utilizando macros).

Un mixin es una forma de agrupar funcionalidad y agregársela a múltiples clases de objetos, sin que estas
clases estén conectadas por subclasificación. Es lo que vemos como el mejor trade-off entre simple y múltiple
herencia.
\begin{verbatim}
#@mixin ValueHolder {
  var $value;
  function getValue(){
    return $this->value;
  }
  function setValue($value){
    $this->value = $value;
  }
}@#

class Contador{
  #@use_mixin ValueHolder@#
  function increment(){
    $this->setValue($this->getValue()+1);
  }
}
\end{verbatim}
\subsection{Múltiples Configuraciones}

Para el desarrollo colaborativo, es útil mantener múltiples configuraciones. O para trabajar en distintos
clientes. O para hacer testing y deployment.

Por todo esto, PWB mantiene un archivo de configuraciones múltiples, para adaptar cada una a una necesidad
específica.

\subsection{Compilación}

El uso de macros, y la inclusión de los muchos archivos de PWB, hacen que la carga en cada request pueda ser
muy lenta. Por eso desarrollamos un método de compilar los archivos PHP (para que las macros ya estén procesadas),
y además, habilitamos varias formas de compilación del código (todo a un sólo archivo PHP, sólo las clases
utilizadas a un archivo PHP, en archivos separados). Esta configuración es seteable desde los archivos de
configuración.


