\section{Trabajos Relacionados}

\begin{itemize}
\item Muchos frameworks toman el enfoque de programar el controller mediante ``páginas''\cite{cake, RoR}. \PWB\ tuvo en un principio esta forma, pero finalmente elegimos componentes \cite{seaside,Duca04e}, dado que consideramos que incrementa la composicionalidad.

%Utilizamos además, el concepto de Widgets \cite{WDGTS}, muy conocido entre las aplicaciones de interacción con los usuarios.

\item Para la generación de las vistas, encontramos 2 enfoques:
\begin{itemize}
\item \emph{HTML Programático}: Cada componente tiene un método propio para renderearse.
\item \emph{Templates Programáticos}: Son templates que alternan código ejecutable y HTML, y para asociarse a un componente son ejecutados.
\end{itemize}
En lugar de los métodos anteriores, decidimos utlizar ``Templates Declarativos'': Templates que definen lo que se va a mostrar, pero no se ejecutan. Esto permite, por ejemplo, que una colección de elementos sea modificada durante la ejecución, y de esta manera solamente renderear la parte modificada (cuando de la otra forma deberíamos haber redibujado todo, por la necesidad de volver a ejecutar el template completo).

%Dado que no se utiliza programación para la vista, \PWB \ no utiliza Helpers para el AJAX de las páginas, porque lo ofrece de manera transparente.

\item Para el modelo, utilizamos el mecanismo del pattern ActiveRecord \cite{activerecord}, usado también por varios sistemas de persistencia \cite{cake, RoR, hibernate, glorp}. Dentro de lo que es este pattern, elegimos:
\begin{itemize}
\item mapeo Class-Table \cite{classtable}, donde existe una tabla en la Base de Datos por cada clase en el modelo, y
\item adaptación de la Base de Datos a partir de Clases, en lugar de adaptación de Clases a partir de la Base de Datos \cite{cake, RoR}, porque creemos que simplifica la tarea del programador poder editar su modelo de clases en un lenguaje que tenga integrado el concepto de herencia, y porque no tiene el costo de pasar de un lenguaje a otro para hacer el esquema de datos, y el manejo de los mismos.
\end{itemize}

Para la recuperación de objetos, existe el enfoque de utilizar SQL directamente, utilizar objetos que definen una consulta a realizar \cite{cake, RoR}, o tener un lenguage para hacer las consultas \cite{hibernate}.  Nosotros tenemos un lenguaje de consulta (OQL) que traduce a Objetos que definen la consulta. Este enfoque nos parece mejor dado que abstrae al usuario del mapeo a SQL (los objetos hacen ese trabajo) y el OQL abstrae de la creación de estos objetos. Nombramos al nuestro OQL por el lenguaje OQL (Object Query Language) \cite{OQL} de la ODMG.


%\item  Para \PITS, Smalltalk también fue una fuente de recursos, con los Eventos, las Weak References,

%Las Macros \cite{macros} son similares a las del preprocessor de C.

%La técnica de Compilación cacheada es del Transparent AOP \cite{aop}.

%Los Compiler Compiler más conocidos son YACC \cite{YACC} y Bison \cite{BISON}, pero más similar al nuestro es el Parsec \cite{PARSEC}, por ser LALL.

%Los DSL \cite{DSLs}.

\end{itemize}